# DOL死锁
##### 实验现象
![Alt text](http://p1.bpimg.com/567571/cdcc68285e8eb2ae.png)

##### 死锁发生的四个条件
###### 1.互斥条件：同一个资源同一时间内只能被一个进程使用；    
###### 2.占有且等待：一个进程在持有一个资源的同时，被正在请求的另一个资源阻塞；
###### 3.资源不可剥夺：对于进程已经获取的资源，在其使用完之前不能被其它进程剥夺；
###### 4.循环等待：多个进程间存在资源循环等待的情况；

##### 本次实验中死锁发生的原因
对于class A和class B而言，它们中的函数methodA, methodB和last都是同步代码块，这也就意味着在同一时刻内method函数和last函数不能同时运行。    

当程序开始运行时，主线程调用Deadlock函数开始执行，当运行到t.start()时新线程t被创建。在t被创建之后，主线程仍然在运行，经过count延时之后，将会调用a.methodA()，而a.methodA()中将会调用b.last()，相当于此时主线程在执行（占有）b.last()。对于线程t而言，它和主线程类似，会调用b.methodB(),相当于申请b.methodB()。    

那么此时，a.last()正在被主线程占有着，和它有同步关系的a.methodB()就不能被执行只能阻塞。当a.last()执行完后，a.methodB()才可以执行，继续调用a.last()。    

若线程t和主线程之间开始运行的时间相隔很短，则线程t的b.method先运行，还未调用a.last，主线程的a.method就运行了，则线程t先被阻塞；主线程的a.method此时调用b.last，发现b.method还没有执行完，所以b.last无法执行，a.method被阻塞。两个线程互相循环等待的关系，那么它们之间就发生了死锁。